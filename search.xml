<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于路径积分-蒙特卡洛方法的简单一维场]]></title>
    <url>%2F2019-07-26%2Fqed1%2F</url>
    <content type="text"><![CDATA[相关理论一维场即一维空间加上一维时间 基于拉氏量的路径积分 一维标量场给等效成空间内分立格点的（在空间维与时间维具有双重周期条件的）类似与固体物理的布洛赫定理的场。 核心方法：量子力学之中的变分法。稳定的经典场系统的作用量总是取最小值，量子力学之中不确定原理导致非最小作用量的状态仍然有机会出现。量子系统的具体状态由概率确定，由作用量小的状态向作用量大的状态变化（非时间演化）的概率由作用量的差值的负指数确定。 格点方法下的场的拉格朗日量。具体方法见ppt截图。 编程与计算python与C++混合编程。C++编译计算模块加速运算性能，利用python的众多的数据处理与分析工具进行可视化输出与处理。 相关的C++程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;random&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;extern "C"&#123; int cal(double *dog, int Ndex, int Tdex, int Xdex, int Nmax, int Tmax, int Xmax, double msq, double lam, double dx);&#125;double ps(double *dog, int X, int T, int N, int Xmax, int Tmax, double lam, double msq, int Nindex, int Xindex, int Tindex)&#123; int Xb = X - 1; int Xf = X + 1; int Tb = T - 1; int Tf = T + 1; if (Xb &lt; 0) &#123; Xb = Xmax - 1; &#125; if (Tf &gt;= Tmax) &#123; Tf = 0; &#125; if (Tb &lt; 0) &#123; Tb = Tmax - 1; &#125; if (Tf &gt;= Tmax) &#123; Xf = 0; &#125; return pow(dog[N * Nindex + T * Tindex + X * Xindex] - dog[N * Nindex + Tf * Tindex + X * Xindex], 2) + pow(dog[N * Nindex + T * Tindex + X * Xindex] - dog[N * Nindex + Tb * Tindex + X * Xindex], 2) + pow(dog[N * Nindex + T * Tindex + X * Xindex] - dog[N * Nindex + T * Tindex + Xf * Xindex], 2) + pow(dog[N * Nindex + T * Tindex + X * Xindex] - dog[N * Nindex + T * Tindex + Xb * Xindex], 2) + msq * pow(dog[N * Nindex + T * Tindex + X * Xindex], 2) + lam * msq * pow(dog[N * Nindex + T * Tindex + X * Xindex], 2);&#125;int cal(double *dog, int Ndex, int Tdex, int Xdex, int Nmax, int Tmax, int Xmax, double msq, double lam, double dx)&#123; int acp = 0; int xx; int tt; std::default_random_engine seed; seed.seed(time(NULL)); // seed.seed(1234); // std::uniform_real_distribution&lt;double&gt; ran1(-0.1,0.1); std::uniform_real_distribution&lt;double&gt; ran2(-1.0, 1.0); std::uniform_real_distribution&lt;double&gt; ran3(0, 1.0); std::vector&lt;int&gt; T_iter; std::vector&lt;int&gt; X_iter; for (int i = 0; i &lt; Tmax; i++) &#123; T_iter.push_back(i); &#125; for (int i = 0; i &lt; Xmax; i++) &#123; X_iter.push_back(i); &#125; for (int in = 1; in &lt; (Nmax - 1); in++) &#123; for (int ix = 0; ix &lt; Xmax; ix++) &#123; for (int it = 0; it &lt; Tmax; it++) &#123; dog[(in + 1) * Ndex + ix * Xdex + it * Tdex] = dog[(in)*Ndex + ix * Xdex + it * Tdex]; &#125; &#125; std::random_shuffle(X_iter.begin(), X_iter.end()); std::random_shuffle(T_iter.begin(), T_iter.end()); for (int ix = 0; ix &lt; Xmax; ix++) &#123; for (int it = 0; it &lt; Tmax; it++) &#123; xx = X_iter[ix]; tt = T_iter[it]; dog[(in + 1) * Ndex + xx * Xdex + tt * Tdex] = dog[(in + 1) * Ndex + xx * Xdex + tt * Tdex] + dx * ran2(seed); double ds = ps(dog, xx, tt, (in + 1), Xmax, Tmax, lam, msq, Ndex, Xdex, Tdex) - ps(dog, xx, tt, (in), Xmax, Tmax, lam, msq, Ndex, Xdex, Tdex); double pan = ran3(seed); if (pan &lt; exp(-ds)) &#123; /* code */ &#125; else &#123; dog[(in + 1) * Ndex + xx * Xdex + tt * Tdex] = dog[(in)*Ndex + xx * Xdex + tt * Tdex]; &#125; &#125; &#125; &#125; return 0;&#125; 编译指令： 12g++ -shared -fPIC d.cpp -o d.so python部分: 123456789101112import numpy as npimport matplotlib.pyplot as pltimport time#plt.rcParams['font.sans-serif']=['FangSong_GB2312'] #用来正常显示中文标签from matplotlib.font_manager import _rebuild_rebuild()#重新创建字体索引列表import matplotlibmatplotlib.rcParams['font.family']=['Microsoft YaHei']plt.rcParams['axes.unicode_minus']=False #用来正常显示负号import mathfrom ctypes import *import numpy.ctypeslib as npct 面向对象的编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class zutai(object): def __init__(self,a=0.1,N=6000,la=0,m=1,ls=1): self.mass=m self.a=a self.N=N self.nx=int(5/a) self.nt=int(10/a) self.msq=math.pow(m*a,2) self.lam=la*a*a self.ls=ls self.dog=np.zeros([self.N,self.nt,self.nx],dtype='float64') self.Ndex=self.dog.shape[1]*self.dog.shape[2] self.Tdex=self.dog.shape[2] self.Xdex=1 self.Nmax=self.dog.shape[0] self.Tmax=self.dog.shape[1] self.Xmax=self.dog.shape[2] self.ldoglib=npct.load_library('d','.') array_1d_double = npct.ndpointer(dtype=np.float64, ndim=3, flags='CONTIGUOUS') self.ldoglib.cal.argtypes=[array_1d_double,c_int,c_int,c_int,c_int,c_int,c_int,c_double,c_double,c_double] self.ldoglib.cal.restype=c_int pass def cal(self): self. ldoglib.cal(self.dog,self.Ndex,self.Tdex,self.Xdex,self.Nmax,self.Tmax,self.Xmax,self.msq,self.lam,self.ls) pass def tu(self): av=np.zeros(self.dog.shape[0]) for lu in range(0,self.dog.shape[0]): av[lu]=np.mean(self.dog[lu,:,:]**2) pass plt.figure() plt.plot(av) tit='$\phi^&#123;2&#125;$平均值变化图'+' a='+str(self.a)+'$\lambda = $ '+str(self.lam)+' m='+str(self.mass) plt.title(tit) plt.xlabel('组态数') plt.savefig('phi'+str((time.time()))+'.png') plt.show()# def jt(self,NUM=70,Lang=25,St=1000,jian=50,zhi=21):# fu=np.zeros([NUM,Lang])# llk=np.zeros(NUM)# for kl in range(0,NUM):# for ti in range(0,Lang):# fu[kl,ti]=np.mean((self.dog[St+jian*kl,0,:])*(self.dog[St+jian*kl,ti,:]))# pass# pass # llu=fu.mean(axis=0)# llue=fu.var(axis=0)# # print('误差：'+str(llue))# lluu=(np.log(np.abs(llu)))[:zhi]# x=np.linspace(0,(zhi-1)/10,zhi)# ooo=np.polyfit(x,lluu,1)# yyy=ooo[0]*x+ooo[1]# print(ooo[0])# self.eng=ooo[0]# plt.figure()# plt.plot(x,lluu,'rx')# plt.plot(x,yyy,'-')# # for nnn in range(0,NUM):# # ddog=(np.log(np.abs(llu)))[nnn,:zhi]# # llk[nnn]=np.polyfit(x,ddog,1)# # pass# # self.res=llk pass def ek(self,St=3000,jiange=98,dianshu=30,shijian=10,qv=6): lp=np.zeros([dianshu,self.nx])# tfrt=np.zeros([50,10,50]) for up in range(dianshu): hu=self.dog[St+jiange*up,:,:] ss=np.zeros_like(hu,dtype='complex') for ii in range(self.nt): ss[ii,:]=np.fft.fft(hu[ii,:]) frt=np.zeros([shijian,self.nx],dtype='complex') for aa in range(shijian): er=np.zeros(self.nx) for bb in range(self.nt): er=er+(ss[bb,:].conjugate()*ss[(bb+aa)%self.nt,:]) # if aa==9 and up==1: # print((bb+aa)%100) # pass frt[aa,:]=er for down in range(self.nx): sls=frt[:,down] wew=np.log(sls) # wew.shape xcx=np.linspace(0,1-self.a,shijian) xcx.shape llll=np.polyfit(xcx[:qv],wew[:qv],1)[0] #print() lp[up,down]=(float(llll)) mme=np.zeros(self.nx) meer=np.zeros(self.nx) xday=np.zeros(self.nx) for kku in range(self.nx): mme[kku]=-lp[:,kku].mean() meer[kku]=lp[:,kku].var() xday[kku]=kku plt.figure() plt.errorbar(xday[:int(self.nx/2)],mme[:int(self.nx/2)],yerr=meer[:int(self.nx/2)],fmt='rx:',ecolor='b',capthick=2,capsize=4) tit='色散关系图 a='+str(self.a)+'$\lambda = $ '+str(self.lam)+' m='+str(self.mass) plt.title(tit) plt.xlabel("k") plt.ylabel('m')# plt.savefig() plt.savefig('san'+str((time.time()))+'.png') plt.show() return [mme,meer] 1234dd=zutai()#初始化dd.cal()#进行计算dd.tu()#画出平均数据[a,b]=dd.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(m=2)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 12[a,b]=d2.ek(jiange=74,St=3040)#数据不够理想，可以更改采样点#算了不调了，就这样了 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(m=3)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1[a,b]=d2.ek(jiange=27)#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part m越大越离谱，减小m试试看 1234d2=zutai(m=0.5)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(m=0.25)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=0.5)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=10)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=0.5)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=1,a=0.1)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=1,a=0.05)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=1,a=0.2)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 1234d2=zutai(la=1,a=0.125)#初始化d2.cal()#进行计算d2.tu()#画出平均数据[a,b]=d2.ek()#生成色散关系 /home/yu/.local/lib/python3.6/site-packages/ipykernel_launcher.py:94: ComplexWarning: Casting complex values to real discards the imaginary part 数据点过少，结果看看就行，不要当真。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于Markov chains 计算一维谐振子基态能量]]></title>
    <url>%2F2019-07-24%2Fqed2%2F</url>
    <content type="text"><![CDATA[利用马可夫链计算一维谐振子的基态能量 计算作用量 $$ dS=\frac{(u_{n-1}+u_{n})^{2}}{2a\omega}+\frac{a\omega(u_{n-1}^{2}+u_{n}^{2})}{4} +\frac{(u_{n+1}+u_{n})^{2}}{2a\omega}+\frac{a\omega(u_{n+1}^{2}+u_{n}^{2})}{4} $$ 在一系列旧点之上乱序选取，加上某个范围内的随机数，新点与旧点进行局部作用量比较，作用量如减小，则接受新点。如果作用量增大，则按照概率$e^{dS_{2}-dS{1}}$确定是否接受。不接受的点保留旧值。 12345double weight(double x0, double x1, double x2, double aomega)&#123; double S=0.0; S=(x1-x0)*(x1-x0)/(2.0*aomega) + aomega*(x0*x0+x1*x1)/4.0 + (x2-x1)*(x2-x1)/(2.0*aomega) + aomega*(x2*x2+x1*x1)/4.0; return exp(-1.0*S);&#125; 产生若干（很多）组态之后，对后面的组态求平方平均值即为基态能量。 12345import numpy as npimport matplotlib.pyplot as pltimport mathfrom ctypes import *import numpy.ctypeslib as npct 12libcd = npct.load_library("pf", ".")array_1d_double = npct.ndpointer(dtype=np.float64, ndim=2, flags='CONTIGUOUS') 12libcd.hhh.argtypes=[array_1d_double,c_int,c_int,c_double,c_double]libcd.hhh.restype=c_int 1lu=np.zeros([130000,500],dtype='float64') 1libcd.hhh(lu,130000,500,0.1,0.2) 1612suu=np.zeros(130000)sii=lu**2 12for kk in range(0,130000): suu[kk]=np.mean(sii[kk,:]) 1plt.plot(suu[10000::600])#为防止关联性每600个取数据。 [&lt;matplotlib.lines.Line2D at 0x7f8d80dda898&gt;] 1plt.plot(suu) [&lt;matplotlib.lines.Line2D at 0x7f8d405b7710&gt;] 1plt.hist(suu[100000::],40,histtype='bar',facecolor='yellowgreen',alpha=0.75) #方均值分布 (array([ 59., 204., 421., 739., 653., 868., 1014., 1371., 1563., 1890., 1927., 1802., 1762., 1831., 1505., 1209., 1271., 1342., 1111., 1041., 907., 809., 658., 616., 520., 426., 294., 300., 394., 306., 263., 203., 161., 154., 107., 70., 109., 86., 27., 7.]), array([0.30646848, 0.32209395, 0.33771941, 0.35334488, 0.36897034, 0.3845958 , 0.40022127, 0.41584673, 0.4314722 , 0.44709766, 0.46272313, 0.47834859, 0.49397406, 0.50959952, 0.52522499, 0.54085045, 0.55647592, 0.57210138, 0.58772684, 0.60335231, 0.61897777, 0.63460324, 0.6502287 , 0.66585417, 0.68147963, 0.6971051 , 0.71273056, 0.72835603, 0.74398149, 0.75960695, 0.77523242, 0.79085788, 0.80648335, 0.82210881, 0.83773428, 0.85335974, 0.86898521, 0.88461067, 0.90023614, 0.9158616 , 0.93148707]), &lt;a list of 40 Patch objects&gt;) 1np.mean(suu[10000::600]) 0.495475057671359851hy=lu[10000::600] 123loo=np.zeros(500)for po in range(0,500): loo[po]=np.mean(lu[10000,:]*lu[10000+po*1,:]) 1plt.plot((looo[5:50]),'rx') [&lt;matplotlib.lines.Line2D at 0x7f8d3f03e208&gt;] 1looo=np.log(loo) 1loo array([ 0.34280532, 0.13145158, 0.09545402, 0.05821956, 0.11446664, -0.00101133, 0.01600951, 0.01831628, 0.03161569, 0.03762436, 0.04253305, 0.03503241, -0.01741445, 0.0206876 , 0.0559742 , 0.00657246, 0.02660626, 0.04883725, 0.02803961, 0.04471572, -0.03246027, 0.02030995, 0.04995083, 0.08313026, 0.03374789, 0.02868077, -0.04105371, -0.01369022, -0.02838291, -0.01871887, 0.02223757, 0.04172896, 0.01848376, 0.06792485, 0.00939457, -0.0263474 , -0.00551463, 0.06894225, -0.01276136, -0.0205876 ])1np.var(suu[10000::600]) #f方差 0.010724637054091532相关C++ 模块代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;random&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;extern "C"&#123; int hhh(double * x,int hang,int lie, double aw, double dx );&#125;double weight(double x0, double x1, double x2, double aomega)&#123; double S=0.0; S=(x1-x0)*(x1-x0)/(2.0*aomega) + aomega*(x0*x0+x1*x1)/4.0 + (x2-x1)*(x2-x1)/(2.0*aomega) + aomega*(x2*x2+x1*x1)/4.0; return exp(-1.0*S);&#125; int hhh(double * x,int hang,int lie, double aw, double dx )&#123; int Nt,Nconf; double aomega; // a(lattice spacing)*omega(angular frequency) double delta; //update step size // char output_path[200]; // output file path aomega=aw; Nt=lie; Nconf=hang; aomega=aw; delta=dx;// read in input // read_double("aomega", &amp;aomega); // read_int("Nt", &amp;Nt); // read_int("Nconf", &amp;Nconf); // read_double("delta", &amp;delta); // read_string("output_path", output_path); double* x1 = new double[Nt]; double* x2 = new double[Nt]; // double* x = new double[Nt*Nconf]; std::ofstream out; std::default_random_engine seed; seed.seed(time(NULL)); // seed.seed(1234); // std::uniform_real_distribution&lt;double&gt; ran1(-0.1,0.1); std::uniform_real_distribution&lt;double&gt; ran2(-1.0,1.0); std::uniform_real_distribution&lt;double&gt; ran3(0,1.0); // initialize the configuration to be a random number between [-0.1, 0.1] for(int i=0; i&lt;Nt; i++) // *(x1+i) = *(x2+i) = ran1(seed); *(x1+i) = *(x2+i) = 0.0; // cold start// update the configuration with metropolis algorithm std::vector&lt;int&gt; t_iter; for(int i=0; i&lt;Nt; i++) t_iter.push_back(i); for(int n=0; n&lt;Nconf; n++)&#123; std::random_shuffle (t_iter.begin(), t_iter.end()); for(int t=0; t&lt;Nt; t++)&#123; int i=t_iter[t]; *(x2+i) = *(x1+i) + delta*ran2(seed); if(ran3(seed) &lt; weight(*(x2+(i-1+Nt)%Nt),*(x2+i),*(x2+(i+1)%Nt),aomega)/weight(*(x1+(i-1+Nt)%Nt),*(x1+i),*(x1+(i+1)%Nt), aomega)) *(x1+i)=*(x2+i); // accept else *(x2+i)=*(x1+i); // reject &#125; for(int i=0; i&lt;Nt; i++) *(x + n*Nt + i) = *(x2 + i); &#125; 编译指令 12g++ fp.cpp -shared -fPIC -o fp.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派create_ap做wifi热点添加ipv6支持]]></title>
    <url>%2F2019-07-22%2Fcreate_ap-add-ipv6%2F</url>
    <content type="text"><![CDATA[树莓派create_ap做wifi热点通常情况下仅有ipv4功能，没有ipv6功能。其他添加ipv6的方案可以分为两种，一种是ndp，利用ipv6标准的邻居发现协议使所有接入子网的设备获得ipv6地址。另一种是nat66方案，与通行的ipv4 nat相同。 ndp]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派系统服务注册]]></title>
    <url>%2F2019-07-10%2Fraspbian-ser-add%2F</url>
    <content type="text"><![CDATA[树莓派系统服务注册今天给树莓派安装AriaNG时将aria2启动脚本添加/etc/init.d/后报错，系统未发现该服务。后经多方查找，发现只在/etc/init.d/添加启动脚本还不够，需要再次运行 1pi@raspberrypi:~ $ sudo update-rc.d aria2c defaults 其中 aria2c是启动脚本的名字。 附aria2c内容 12345678910111213141516171819202122232425262728#!/bin/sh### BEGIN INIT INFO# Provides: aria2c# Required-Start: $network $local_fs $remote_fs# Required-Stop: $network $local_fs $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: aria2c RPC init script.# Description: Starts and stops aria2 RPC services.### END INIT INFOUSER=rootRETVAL=0case "$1" in start) echo "Starting service Aria2..." aria2c --conf-path=/path/to/config/aria2.conf -D echo "Start service done." ;; stop) echo "Stoping service Aria2..." killall aria2c echo "Stop service done." ;; esac exit $RETVAL]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019-07-10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
